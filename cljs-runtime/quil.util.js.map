{"version":3,"sources":["quil/util.cljc"],"mappings":"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","names":["quil.util/no-fn","quil.util/initial-internal-state","quil.util/resolve-constant-key","key","mappings","cljs.core.get","cljs.core/some","cljs.core/vals","js/Error","cljs.core/vec","cljs.core.sort","cljs.core/keys","quil.util/length-of-longest-key","m","or__4126__auto__","cljs.core/last","p1__43923#","cljs.core.map","var_args","G__43937","quil.util/gen-padding","len","quil.util.gen_padding","pad","s","quil.util/print-definition-list","definitions","longest-key","cljs.core.dorun","p__43939","vec__43940","cljs.core.nth","k","v","diff","cljs.core.println","quil.util/clj-compilation?","quil.util/prepare-quil-name","const-keyword","clojure.string/replace","clojure.string/upper-case","cljs.core/name","quil.util/prepare-quil-clj-constants","constants","cljs.core.into","p1__43943#","cljs.core/PersistentVector","cljs.core.symbol","quil.util/prepare-quil-cljs-constants","p1__43944#","cljs.core.sequence","cljs.core/seq","cljs.core.concat","cljs.core/List","quil.util/make-quil-constant-map","target","const-map-name","const-map","cljs.core._EQ_","quil.util/clj-unchecked-int"],"sourcesContent":["(ns ^{:doc \"Utility fns\"}\n quil.util\n  (:require [clojure.string :as cstr]))\n\n(defn no-fn\n  \"Function that does nothing.\"\n  [])\n\n(def initial-internal-state\n  \"Internal state map used to initiate all sketches.\"\n  {:frame-rate 60\n   :looping? true})\n\n#?(:clj\n   (defn callable? [value]\n     (or (fn? value)\n         (var? value))))\n\n#?(:clj\n   (defn absolute-path [path]\n     (-> (str path)\n         (java.io.File.)\n         (.getAbsolutePath))))\n\n#?(:clj\n   (defn int-like?\n     [val]\n     (let [t (type val)]\n       (or (= java.lang.Long t)\n           (= java.lang.Integer t)))))\n\n(defn resolve-constant-key\n  \"Returns the val associated with `key` in `mappings` or `key` directly if it\n  is one of the vals in `mappings`. Otherwise throws an exception.\"\n  [key mappings]\n  (cond\n    (get mappings key)            (get mappings key)\n    (some #{key} (vals mappings)) key\n\n    :else                         (throw (#?(:clj Exception.\n                                             :cljs js/Error.)\n                                          (str \"Expecting a keyword, got: \" key \". Expected one of: \" (vec (sort (keys mappings))))))))\n\n(defn- length-of-longest-key\n  \"Returns the length of the longest key of map `m`. Assumes `m`'s keys are strings\n   and returns 0 if map is empty:\n\n   Examples:\n   ```\n   (length-of-longest-key {\\\"foo\\\" 1 \\\"barr\\\" 2 \\\"bazzz\\\" 3}) ;=> 5\n   (length-of-longest-key {}) ;=> 0\n   ```\"\n  [m]\n  (or (last (sort (map #(.length %) (keys m))))\n      0))\n\n(defn- gen-padding\n  \"Generates a padding string with `s` concatenated with `len` times `pad`.\n   May be called without starting string `s` in which case it defaults to the\n   empty string and also without `pad` in which case it defaults to a single\n   space.\n\n   Examples:\n   ```\n   (gen-padding \\\"asdf\\\" 5 \\\"b\\\") ;=> \\\"asdfbbbbb\\\"\n   (gen-padding 3 \\\"b\\\")          ;=> \\\"bbb\\\"\n   (gen-padding 3)                ;=> \\\"   \\\"\n   ```\n   \"\n  ([len] (gen-padding \"\" len \" \"))\n  ([len pad] (gen-padding \"\" len pad))\n  ([s len pad]\n   (if (> len 0)\n     (gen-padding (str s pad) (dec len) pad)\n     s)))\n\n(defn print-definition-list\n  [definitions]\n  (let [longest-key (length-of-longest-key definitions)]\n    (dorun\n     (map (fn [[k v]]\n            (let [len (.length k)\n                  diff (- longest-key len)\n                  pad (gen-padding diff)]\n              (println k pad \"- \" v)))\n          definitions))))\n\n(defn clj-compilation? []\n  #?(:clj\n     (not\n      (boolean\n       (when-let [n (find-ns 'cljs.analyzer)]\n         (when-let [v (ns-resolve n '*cljs-file*)]\n           @v))))\n     :cljs false))\n\n(defn prepare-quil-name [const-keyword]\n  (cstr/replace\n   (cstr/upper-case (name const-keyword))\n   #\"-\" \"_\"))\n\n(defn prepare-quil-clj-constants [constants]\n  (into {}\n        (map\n         #(vector % (symbol (str \"PConstants/\" (prepare-quil-name %))))\n         constants)))\n\n(defn prepare-quil-cljs-constants [constants]\n  (into {}\n        (map\n         #(vector % `(aget js/p5.prototype ~(prepare-quil-name %)))\n         constants)))\n\n(defn make-quil-constant-map [target const-map-name const-map]\n  `(def ^{:private true}\n     ~const-map-name\n     ~(if (= target :clj)\n        (prepare-quil-clj-constants const-map)\n        (prepare-quil-cljs-constants const-map))))\n\n(defmacro generate-quil-constants [target & opts]\n  `(do\n     ~@(map\n        #(make-quil-constant-map target (first %) (second %))\n        (partition 2 opts))))\n\n(defn clj-unchecked-int\n  \"In clojure it does `unchecked-int` and does nothing in cljs.\n  Needed to handle colors in hex form in clojure.\"\n  [v]\n  #?(:clj (unchecked-int v) :cljs v))\n"]}